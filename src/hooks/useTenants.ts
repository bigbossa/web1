
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/providers/AuthProvider";
import type { Database } from "@/integrations/supabase/types";
import { Action } from "@radix-ui/react-toast";


type Tenant = Database['public']['Tables']['tenants']['Row'] & {
    current_room?: {
    id: string;
    room_number: string;
    room_type: string;
    floor: number;
  } | null;
};
type TenantInsert = Database['public']['Tables']['tenants']['Insert']& {
   id?: string;
  first_name: string;
  last_name: string;
  email: string;
  phone: string;
  address: string;
  created_at?: string;
};
type TenantUpdate = Database['public']['Tables']['tenants']['Update'];

type RoomUpdate = Database['public']['Tables']['rooms']['Update']& {
   tenant_id?: string;
};

export const useTenants = () => {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const { user , session} = useAuth();

  const {
    data: tenants = [],
    isLoading,
    error
  } = useQuery({
    queryKey: ['tenants'],
    queryFn: async () => {
      console.log('Fetching tenants...');
      
      // First get all tenants
      const { data: tenantsData, error: tenantsError } = await supabase
        .from('tenants')
        .select('*')
        .order('created_at', { ascending: false });

      if (tenantsError) {
        console.error('Error fetching tenants:', tenantsError);
        throw tenantsError;
      }

      console.log('Tenants fetched:', tenantsData);

      // Then get current occupancy with room details for each tenant
      const tenantsWithRooms = await Promise.all(
        (tenantsData || []).map(async (tenant) => {
          const { data: occupancyData } = await supabase
            .from('occupancy')
            .select(`
              room_id,
              rooms!occupancy_room_id_fkey(
                id,
                room_number,
                room_type,
                floor
              )
            `)
            .eq('tenant_id', tenant.id)
            .eq('is_current', true)
            .maybeSingle();

          const current_room = occupancyData?.rooms ? {
            id: occupancyData.rooms.id,
            room_number: occupancyData.rooms.room_number,
            room_type: occupancyData.rooms.room_type,
            floor: occupancyData.rooms.floor,
          } : null;

          return {
            ...tenant,
            current_room
          };
        })
      );

      console.log('Tenants with room info:', tenantsWithRooms);
      return tenantsWithRooms;
    },
    enabled: !!user,
  });

const createTenantMutation = useMutation({
  mutationFn: async (newTenant: TenantInsert) => {
    // 1. Insert ‡∏•‡∏á tenants ‡∏Å‡πà‡∏≠‡∏ô
    const { data: tenantData, error: tenantError } = await supabase
      .from("tenants")
      .insert({
        first_name: newTenant.first_name,
        last_name: newTenant.last_name,
        email: newTenant.email,
        phone: newTenant.phone,
        address: newTenant.address,
        emergency_contact: newTenant.emergency_contact || "",
        room_id: newTenant.room_id || "",
        room_number: newTenant.room_number || "",
        residents: newTenant.residents || "",
      })
      .select()
      .single();

    if (tenantError) throw tenantError;

    // 2. ‡∏´‡∏≤ room_id ‡πÅ‡∏•‡∏∞ capacity ‡∏à‡∏≤‡∏Å room_number
    const { data: roomData, error: roomError } = await supabase
      .from("rooms")
      .select("id, capacity")
      .eq("room_number", tenantData.room_number)
      .single();

    if (roomError || !roomData) throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö");

    const room_id = roomData.id;

    // 3. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡πà‡∏≠‡∏ô‡∏ß‡πà‡∏≤ tenant ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏ú‡∏π‡∏Å‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏±‡∏ö‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const { count: existingOccupancyCount, error: existingError } = await supabase
      .from("occupancy")
      .select("*", { count: "exact", head: true })
      .eq("tenant_id", tenantData.id)
      .eq("room_id", room_id)
      .eq("is_current", true);

    if (existingError) throw existingError;

    if (existingOccupancyCount === 0) {
      // 4. Insert occupancy
      const { error: occupancyError } = await supabase
        .from("occupancy")
        .insert({
          tenant_id: tenantData.id,
          room_id: room_id,
          check_in_date: new Date().toISOString().split("T")[0],
          is_current: true,
        });

      if (occupancyError) throw occupancyError;
    }

    // 5. ‡∏î‡∏∂‡∏á count ‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ
    const { count: currentOccupantCount, error: countError } = await supabase
      .from("occupancy")
      .select("*", { count: "exact", head: true })
      .eq("room_id", room_id)
      .eq("is_current", true);

    if (countError) throw countError;

    // üëâ Debug log
    console.log(`‡∏´‡πâ‡∏≠‡∏á ${newTenant.room_number} ‡∏°‡∏µ‡∏ú‡∏π‡πâ‡∏û‡∏±‡∏Å‡∏≠‡∏≤‡∏®‡∏±‡∏¢ ${currentOccupantCount}/${roomData.capacity}`);

   // 6. ‡∏ñ‡πâ‡∏≤‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏ñ‡∏∂‡∏á capacity ‡∏Ñ‡πà‡∏≠‡∏¢‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡πâ‡∏≠‡∏á
    if (currentOccupantCount >= roomData.capacity) {
      const { error: statusError } = await supabase
        .from("rooms")
        .update({ status: "occupied" })
        .eq("id", room_id);
      if (statusError) throw statusError;
    } else {
      // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏ï‡πá‡∏° ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô vacant ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô‡∏ú‡∏¥‡∏î
      await supabase
        .from("rooms")
        .update({ status: "vacant" })
        .eq("id", room_id);
    }

    return tenantData;
  },

  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ["tenants"] });
    queryClient.invalidateQueries({ queryKey: ["available-rooms-with-capacity"] });
    queryClient.invalidateQueries({ queryKey: ["system-stats"] });
    toast({
      title: "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
      description: "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÅ‡∏•‡∏∞‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
    });
  },

  onError: (error) => {
    toast({
      title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
      description: error.message || "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏î‡πâ",
      variant: "destructive",
    });
  },
});


  const updateTenantMutation = useMutation({
    mutationFn: async ({ id, updates }: { id: string; updates: TenantUpdate }) => {
      console.log('Updating tenant:', id, updates);
      const { data, error } = await supabase
        .from('tenants')
        .update(updates)
        .eq('id', id)
        .select()
        .single();

      if (error) {
        console.error('Error updating tenant:', error);
        throw error;
      }

      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tenants'] });
      toast({
        title: "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
        description: "‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
      });
    },
    onError: (error) => {
      console.error('Update tenant error:', error);
      toast({
        title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
        description: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏î‡πâ",
        variant: "destructive",
      });
    },
  });

const deleteTenantMutation = useMutation({
  mutationFn: async (tenantId: string) => {
    console.log("tenantId ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏•‡∏ö:", tenantId);

    // 1. ‡∏î‡∏∂‡∏á tenant ‡∏´‡∏•‡∏±‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤ room_id ‡πÅ‡∏•‡∏∞ room_number
    const { data: tenant, error: tenantFetchError } = await supabase
      .from("tenants")
      .select("id, room_id, room_number")
      .eq("id", tenantId)
      .maybeSingle();

    if (tenantFetchError || !tenant) {
      throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤");
    }

    const { room_id: roomId, room_number: roomNumber } = tenant;

    if (!roomId) {
      throw new Error("‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ room_id");
    }

    // 2. ‡∏î‡∏∂‡∏á tenant ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô room ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
    const { data: tenantsInRoom, error: tenantsError } = await supabase
      .from("tenants")
      .select("id")
      .eq("room_id", roomId);

    if (tenantsError || !tenantsInRoom) {
      throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ");
    }

    const tenantIds = tenantsInRoom.map((t) => t.id);

    // 3. ‡∏î‡∏∂‡∏á profiles ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö tenant ‡∏û‡∏ß‡∏Å‡∏ô‡∏µ‡πâ
    const { data: profiles, error: profilesError } = await supabase
      .from("profiles")
      .select("id, tenant_id")
      .in("tenant_id", tenantIds);

    if (profilesError) {
      throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á profiles ‡πÑ‡∏î‡πâ");
    }

    const userIds = profiles.map((p) => p.id);

    // 4. ‡∏•‡∏ö tenant_id, staff_id ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å profiles
    if (userIds.length > 0) {
      const { error: updateProfileError } = await supabase
        .from("profiles")
        .update({ tenant_id: null, staff_id: null })
        .in("id", userIds);

      if (updateProfileError) {
        throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡πâ‡∏≤‡∏á tenant_id ‡πÉ‡∏ô profiles ‡πÑ‡∏î‡πâ");
      }
    }

    // 5. ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏≠‡∏≤‡∏ï‡πå‡∏à‡∏≤‡∏Å occupancy
    const { error: checkoutError } = await supabase
      .from("occupancy")
      .update({
        is_current: false,
        check_out_date: new Date().toISOString().split("T")[0],
      })
      .in("tenant_id", tenantIds)
      .eq("is_current", true);

    if (checkoutError) {
      throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï check-out occupancy ‡πÑ‡∏î‡πâ");
    }

    // 6. ‡∏•‡∏ö room_id / room_number ‡∏à‡∏≤‡∏Å tenants
    // const { error: clearTenantRoomError } = await supabase
    //   .from("tenants")
    //   .update({ room_id: "", room_number: "" })
    //   .in("id", tenantIds);

    // if (clearTenantRoomError) {
    //   throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ô‡∏ò‡πå‡∏´‡πâ‡∏≠‡∏á‡∏à‡∏≤‡∏Å tenants ‡πÑ‡∏î‡πâ");
    // }

    // 7. ‡∏•‡∏ö tenants
    const { error: deleteTenantError } = await supabase
      .from("tenants")
      .update({action: 2})
      .in("id", tenantIds);

    if (deleteTenantError) {
      throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏î‡πâ");
    }

    // 8. ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô vacant
    const { error: updateRoomStatusError } = await supabase
      .from("rooms")
      .update({ status: "vacant" })
      .eq("id", roomId);

    if (updateRoomStatusError) {
      throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡πà‡∏≤‡∏á‡πÑ‡∏î‡πâ");
    }
    // 9. ‡∏•‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å Supabase Auth
  //   if (userIds.length > 0) {
  //     const resp = await fetch(
  //       "https://mnsotnlftoumjwjlvzus.functions.supabase.co/manage-auth-users",
  //       {
  //         method: "DELETE",
  //         headers: {
  //           "Content-Type": "application/json",
  //           Authorization: `Bearer ${session?.access_token}`,
  //           apikey: "YOUR_API_KEY", // ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å env ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô production
  //         },
  //         body: JSON.stringify({ user_ids: userIds }),
  //       }
  //     );

  //     if (!resp.ok) {
  //       const data = await resp.json();
  //       throw new Error(data.error || "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ");
  //     }
  //   }
  // },

  // onSuccess: () => {
  //   queryClient.invalidateQueries({ queryKey: ["tenants"] });
  //   queryClient.invalidateQueries({ queryKey: ["rooms"] });
  //   toast({
  //     title: "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
  //     description: "‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
  //   });
  // },

  // onError: (error: any) => {
  //   console.error("Delete tenant error:", error);
  //   toast({
  //     title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
  //     description: error.message || "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ",
  //     variant: "destructive",
  //   });
      return "‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß";
  },

  onSuccess: (message) => {
    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï query cache ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡∏ñ‡πâ‡∏≤‡πÉ‡∏ä‡πâ React Query)
    queryClient.invalidateQueries({ queryKey: ["tenants"] });
    queryClient.invalidateQueries({ queryKey: ["rooms"] });

    // ‡πÅ‡∏™‡∏î‡∏á toast ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
    toast({
      title: "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
      description: message || "‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
    });
  },

  onError: (error: any) => {
    console.error("Delete tenant error:", error);
    toast({
      title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
      description: error.message || "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ",
      variant: "destructive",
    });
  },
});

const deleteRentedchildMutation = useMutation({
  mutationFn: async (tenantId: string) => {
    console.log("tenantId ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏•‡∏ö:", tenantId);

    // 1. ‡∏î‡∏∂‡∏á tenant ‡∏´‡∏•‡∏±‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤ room_id
    const { data: tenant, error: tenantFetchError } = await supabase
      .from("tenants")
      .select("id, room_id, room_number, residents")
      .eq("id", tenantId)
      .maybeSingle();

    if (tenantFetchError || !tenant) {
      throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤");
    }

    const { room_id: roomId } = tenant;

    if (!roomId) {
      throw new Error("‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ room_id");
    }

    // 2. ‡∏î‡∏∂‡∏á tenants ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô (‡∏û‡∏£‡πâ‡∏≠‡∏° residents)
    const { data: tenantsInRoom, error: tenantsError } = await supabase
      .from("tenants")
      .select("id, residents") 
      .eq("room_id", roomId);

    if (tenantsError || !tenantsInRoom) {
      throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ");
    }

    // 3. ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ tenant ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏•‡∏π‡∏Å‡πÄ‡∏ä‡πà‡∏≤ (‡∏°‡∏µ residents ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà tenant ‡∏´‡∏•‡∏±‡∏Å)
    const rentedChildTenants = tenantsInRoom.filter(
      (t) => t.residents !== null && t.id !== tenantId
    );

    const tenantIdsToDelete = rentedChildTenants.map((t) => t.id);

    if (tenantIdsToDelete.length === 0) {
      throw new Error("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏•‡∏π‡∏Å‡πÄ‡∏ä‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏•‡∏ö‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ");
    }

    // 4. ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏≠‡∏≤‡∏ï‡πå‡∏à‡∏≤‡∏Å occupancy
    const { error: checkoutError } = await supabase
      .from("occupancy")
      .update({
        is_current: false,
        check_out_date: new Date().toISOString().split("T")[0],
      })
      .in("tenant_id", tenantIdsToDelete)
      .eq("is_current", true);

    if (checkoutError) {
      throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï check-out occupancy ‡πÑ‡∏î‡πâ");
    }

    // 5. ‡∏•‡∏ö tenants
    const { error: deleteTenantError } = await supabase
      .from("tenants")
      .update({action: 2})
      .in("id", tenantIdsToDelete);

    if (deleteTenantError) {
      throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏î‡πâ");
    }
  },

  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ["tenants"] });
    queryClient.invalidateQueries({ queryKey: ["rooms"] });
    window.location.reload();
    toast({
      title: "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
      description: "‡∏•‡∏ö‡∏•‡∏π‡∏Å‡πÄ‡∏ä‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
    });
  },

  onError: (error: any) => {
    console.error("Delete tenant error:", error);
    toast({
      title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
      description: error.message || "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏•‡∏π‡∏Å‡πÄ‡∏ä‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ",
      variant: "destructive",
    });
  },
});


const assignRoomMutation = useMutation({
  mutationFn: async ({ tenantId, roomId }: { tenantId: string; roomId: string }) => {
    console.log('Assigning room:', { tenantId, roomId });

    // 1. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á
    const { data: roomData, error: roomError } = await supabase
      .from('rooms')
      .select('capacity, room_number')
      .eq('id', roomId)
      .single();

    if (roomError) throw roomError;

    // 2. ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ (is_current = true)
    const { data: currentOccupancy, error: occupancyError } = await supabase
      .from('occupancy')
      .select('tenant_id')
      .eq('room_id', roomId)
      .eq('is_current', true);

    if (occupancyError) throw occupancyError;

    const currentOccupants = currentOccupancy?.length || 0;
    if (currentOccupants >= roomData.capacity) {
      throw new Error('‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏ï‡πá‡∏°‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏î‡πâ');
    }

    // 3. ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏≠‡∏≤‡∏ï‡πå‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏° (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
    await supabase
      .from('occupancy')
      .update({
        is_current: false,
        check_out_date: new Date().toISOString().split('T')[0],
      })
      .eq('tenant_id', tenantId)
      .eq('is_current', true);

    // 4. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
    const { data, error } = await supabase
      .from('occupancy')
      .insert({
        tenant_id: tenantId,
        room_id: roomId,
        check_in_date: new Date().toISOString().split('T')[0],
        is_current: true,
      })
      .select()
      .single();

    if (error) throw error;

    // 5. ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï tenant ‡∏î‡πâ‡∏ß‡∏¢ room_number
    const { error: updateTenantError } = await supabase
      .from('tenants')
      .update({ room_number: roomData.room_number ,room_id: roomId})
      .eq('id', tenantId);

    if (updateTenantError) throw updateTenantError;

    // ‚úÖ ‡∏•‡∏ö tenant_id ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤ (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ) ‚Üí ‡∏Ç‡πâ‡∏≤‡∏°‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏£‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ tenant_id ‡πÉ‡∏ô rooms ‡πÅ‡∏•‡πâ‡∏ß

    // 6. ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô occupied ‡πÄ‡∏™‡∏°‡∏≠
    await supabase
      .from('rooms')
      .update({ status: 'occupied' })
      .eq('id', roomId);


    return data;
  },

  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['tenants'] });
    queryClient.invalidateQueries({ queryKey: ['available-rooms-with-capacity'] });
    queryClient.invalidateQueries({ queryKey: ['system-stats'] });
    toast({
      title: "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
      description: "‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
    });
  },

  onError: (error) => {
    toast({
      title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
      description: error.message || "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏´‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ",
      variant: "destructive",
    });
  },
});

  return {
    tenants,
    isLoading,
    error,
    createTenant: createTenantMutation.mutate,
    updateTenant: updateTenantMutation.mutate,
    deleteTenant: deleteTenantMutation.mutate,
    deleteRentedchild: deleteRentedchildMutation.mutate,
    assignRoom: (tenantId: string, roomId: string) => assignRoomMutation.mutate({ tenantId, roomId }),
    isCreating: createTenantMutation.isPending,
    isUpdating: updateTenantMutation.isPending,
    isDeleting: deleteTenantMutation.isPending,
    isAssigningRoom: assignRoomMutation.isPending,
  };
};
